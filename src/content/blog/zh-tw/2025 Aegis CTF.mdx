---
title: 2025 ç¥ç›¾ç›ƒâ€”è³‡å®‰ç«¶è³½ Writeup
published: 2025-06-30
description: 2025 ç¥ç›¾ç›ƒâ€”è³‡å®‰ç«¶è³½ Writeup
tags: [AIS3, CTF, Writeup, Web, Misc, Rev]
category: CTF Writeup
licenseName: "Unlicensed"
author: æµ·çº
sourceLink: "https://about.seaotter.cc/zh-tw/posts/db685cac"
draft: false
cover: /src/assets/blog/2025_Aegis_CTF/aegis_banner.png
---
import { Image } from "astro:assets";
import score1 from '/src/assets/blog/2025_Aegis_CTF/AEGIS2025 Â· 7.01pm Â· 09-27.jpeg';
import score2 from '/src/assets/blog/2025_Aegis_CTF/AEGIS2025.jpeg';


# 2025 ç¥ç›¾ç›ƒâ€”è³‡å®‰ç«¶è³½ Writeup

## Web

### HiProxy

é€™é¡Œæ˜¯ä½¿ç”¨ HAProxy 2.2.16 ç‰ˆæœ¬ï¼Œä¸¦é…ç½® ACL ä¾†é”æˆ `/guest` å’Œ `/admin` æµé‡çš„éæ¿¾èˆ‡è½‰ç™¼ã€‚
åœ¨å‰å¤§çš„ LLM çš„å”åŠ©ä¸‹ï¼Œç™¼ç¾ æ­¤ç‰ˆæœ¬çš„ HAProxy å­˜åœ¨ä¸€å€‹å·²çŸ¥çš„ CVE-2021-40346 (HTTP request smuggling) æ¼æ´ï¼Œ
ä¸¦ä¸”å¯ä»¥åˆ©ç”¨é€™å€‹æ¼æ´ä¾†ç¹é ACL çš„æª¢æŸ¥ï¼ŒæˆåŠŸè¨ªå•åˆ° `/admin` é é¢ï¼Œå–å¾— flagã€‚

## Misc

### Nesting Zip

é€™é¡Œæ˜¯çµ¦äº†ä¸€å€‹ zip æª”æ¡ˆæª”æ¡ˆå…§æœ‰ä¸€å€‹ zip æª”æ¡ˆï¼Œè£¡é¢åˆæœ‰ä¸€å€‹ zip æª”æ¡ˆï¼Œä¸€ç›´é‡è¤‡ä¸‹å»ã€‚
ç‚ºäº†åŠ å¿«é€Ÿåº¦ä½¿ç”¨ python çš„ zipfile æ¨¡çµ„ä¾†è§£å£“ç¸®ã€‚

```python
import zipfile
import os
import sys

# æé«˜éè¿´æ·±åº¦é™åˆ¶
sys.setrecursionlimit(100000)

def extract_nested_zip(zip_path, extract_to, depth=0, max_depth=100000):
    """éè¿´è§£å£“ç¸®ï¼Œæ‰¾å‡ºæœ€çµ‚çš„æ–‡å­—æª”"""

    if depth > max_depth:
        return None, f"é”åˆ°æœ€å¤§æ·±åº¦ {max_depth}"

    # æ¯ 100 å±¤å°ä¸€æ¬¡é€²åº¦
    if depth % 100 == 0:
        print(f"é€²åº¦: æ·±åº¦ {depth}")

    log = f"{'  ' * (depth % 10)}[{depth}] {os.path.basename(zip_path)}\n"

    temp_dir = os.path.join(extract_to, f"L{depth}")
    os.makedirs(temp_dir, exist_ok=True)

    try:
        with zipfile.ZipFile(zip_path, 'r') as zip_ref:
            zip_ref.extractall(temp_dir)

        contents = os.listdir(temp_dir)

        for item in contents:
            item_path = os.path.join(temp_dir, item)

            if item.endswith('.txt'):
                log += f"\n{'='*60}\næ‰¾åˆ°ï¼æ·±åº¦ {depth}: {item}\n{'='*60}\n"
                with open(item_path, 'r', encoding='utf-8', errors='ignore') as f:
                    content = f.read()
                print(f"\næ‰¾åˆ°æ–‡å­—æª”æ–¼æ·±åº¦ {depth}ï¼")
                return content, log

            elif item.endswith('.zip'):
                result, sub_log = extract_nested_zip(item_path, extract_to, depth + 1, max_depth)
                if result:
                    return result, log + sub_log

    except Exception as e:
        log += f"éŒ¯èª¤ @{depth}: {str(e)[:100]}\n"

    return None, log

if __name__ == "__main__":
    zip_file = "./Nesting.zip"
    extract_dir = "./nest_extract"
    output_file = "./nest_final.txt"

    if os.path.exists(extract_dir):
        import shutil
        shutil.rmtree(extract_dir)

    os.makedirs(extract_dir, exist_ok=True)

    print("é–‹å§‹è§£å£“ç¸®...")
    result, log = extract_nested_zip(zip_file, extract_dir)

    with open(output_file, 'w', encoding='utf-8') as f:
        if result:
            f.write(f"æˆåŠŸï¼æ–‡å­—æª”å…§å®¹:\n{'='*60}\n")
            f.write(result)
        else:
            f.write("æœªæ‰¾åˆ°æ–‡å­—æª”\n")

    print(f"å®Œæˆï¼çµæœ: {output_file}")
```

è§£å£“ç¸®å®Œæˆå¾Œå¯ä»¥åœ¨ `nest_final.txt` æ‰¾åˆ°ä¸€ä¸²åŠ å¯†çš„æ–‡å­—ã€‚
æ–‡å­—å¦‚ä¸‹ï¼š

```txt
vrq4tqyEs8zIoJLMoIvMk5Oghs+KoJ6gjMycjZrIoLyGncyNvJfMmaDOjKCeoMbPz5ugyJfOkcaC
```

å…ˆå˜—è©¦ base64 è§£ç¢¼ï¼Œå¾—åˆ°ä¸€ä¸²äº‚ç¢¼ï¼Œæ¥è‘—å˜—è©¦ä½¿ç”¨ XOR è§£å¯†ï¼Œä½¿ç”¨ CyberChef çš„ "XOR Brute Force" åŠŸèƒ½ï¼Œ
å˜—è©¦æ‰€æœ‰å¯èƒ½çš„å–®å­—å…ƒ keyï¼Œæœ€å¾ŒæˆåŠŸè§£å‡º flagã€‚

CyberChef Receipe å¦‚ä¸‹ï¼š

```txt
https://gchq.github.io/CyberChef/#recipe=From_Base64('A-Za-z0-9%2B/%3D',false,false)XOR_Brute_Force(3,8,0,'Standard',false,true,false,'AEGIS'/disabled/breakpoint)XOR(%7B'option':'Decimal','string':'255'%7D,'Standard',false)&input=dnJxNHRxeUVzOHpJb0pMTW9Jdk1rNU9naHMrS29KNmdqTXljalpySW9MeUduY3lOdkpmTW1hRE9qS0Nlb01iUHo1dWd5SmZPa2NhQw&oeol=NEL
```

Flag å¦‚ä¸‹ï¼š

```txt
AEGIS{L37_m3_t3ll_y0u_a_s3cre7_Cyb3rCh3f_1s_a_900d_7h1n9}
```

> é€™é¡Œä¸Ÿ LLM è®“ä»–è‡ªå·±å»å˜—è©¦å’Œè¿­ä»£ä¹Ÿè§£çš„å‡ºä¾†ã€‚

## Reverse

### Call Back

é€™é¡Œæ˜¯ä¸€å€‹ Windows PE åŸ·è¡Œæª”çš„ CRT (C Runtime) ã€‚  
é¦–å…ˆï¼Œä¸Ÿé€² Ghidra é€²è¡Œéœæ…‹åˆ†æï¼Œåœ¨é»é€² entry point å¾Œï¼Œç™¼ç¾ç¨‹å¼ä¸€é–‹å§‹æœƒå‘¼å« `FUN_140001db0` å‡½å¼ï¼Œå¦‚ä¸‹ï¼š

```c
/* WARNING: Function: *guard*dispatch_icall replaced with injection: guard_dispatch_icall */
int FUN_140001db0(void)
{
  bool bVar1;
  int iVar2;
  undefined8 uVar3;
  longlong *plVar4;
  ulonglong uVar5;
  IMAGE_DOS_HEADER *pIVar6;
  undefined8 unaff_RBX;

  iVar2 = (int)unaff_RBX;
  uVar3 = __scrt_initialize_crt(1);
  if ((char)uVar3 == '\0') {
    FUN_1400022f8(7);
  }
  else {
    bVar1 = false;
    uVar3 = __scrt_acquire_startup_lock();
    iVar2 = (int)CONCAT71((int7)((ulonglong)unaff_RBX >> 8),(char)uVar3);
    if (DAT_1400058d0 != 1) {
      if (DAT_1400058d0 == 0) {
        DAT_1400058d0 = 1;
        iVar2 = *initterm*e(&DAT_140003300,&DAT_140003318);
        if (iVar2 != 0) {
          return 0xff;
        }
        *initterm(&DAT*1400032e8);
        DAT_1400058d0 = 2;
      }
      else {
        bVar1 = true;
      }
      __scrt_release_startup_lock((char)uVar3);
      plVar4 = (longlong *)FUN_1400022e0();
      if ((*plVar4 != 0) &&
         (uVar5 = __scrt_is_nonwritable_in_current_image((longlong)plVar4), (char)uVar5 != '\0')) {
        (*(code *)*plVar4)(0);
      }
      plVar4 = (longlong *)FUN_1400022e8();
      if ((*plVar4 != 0) &&
         (uVar5 = __scrt_is_nonwritable_in_current_image((longlong)plVar4), (char)uVar5 != '\0')) {
        *register*thread_local_exe_atexit_callback(*plVar4);
      }
      __scrt_get_show_window_mode();
      *get*narrow_winmain_command_line();
      pIVar6 = &IMAGE_DOS_HEADER_140000000;
      iVar2 = FUN_140001530((HINSTANCE)&IMAGE_DOS_HEADER_140000000);
      uVar5 = __scrt_is_managed_app();
      if ((char)uVar5 != '\0') {
        if (!bVar1) {
          _cexit();
        }
        __scrt_uninitialize_crt(CONCAT71((int7)((ulonglong)pIVar6 >> 8),1),'\0');
        return iVar2;
      }
      goto LAB_140001f11;
    }
  }
  FUN_1400022f8(7);
LAB_140001f11:
                    /* WARNING: Subroutine does not return */
  exit(iVar2);
}
```

ä¸Ÿçµ¦ LLM é€²è¡Œåˆ†æï¼Œç™¼ç¾é€™å€‹å‡½å¼ä¸»è¦æ˜¯è² è²¬åˆå§‹åŒ– C Runtime ç’°å¢ƒï¼Œä¸¦å‘¼å« `FUN_140001530` å‡½å¼ä¾†åŸ·è¡Œä¸»è¦çš„ç¨‹å¼é‚è¼¯ã€‚

æ¥è‘—ï¼Œé»é€² `FUN_140001530` å‡½å¼ï¼Œå¦‚ä¸‹ï¼š

```c
void FUN_140001530(HINSTANCE param_1)
{
  int iVar1;
  HWND hWnd;
  undefined1 auStackY_f8 [32];
  WNDCLASSW local_98;
  tagMSG local_48;
  ulonglong local_18;

  local_18 = DAT_140005008 ^ (ulonglong)auStackY_f8;
  local_98.style = 0;
  local_98._4_4_ = 0;
  local_98.cbClsExtra = 0;
  local_98.cbWndExtra = 0;
  local_98.hIcon = (HICON)0x0;
  local_98.hCursor = (HCURSOR)0x0;
  local_98.hbrBackground = (HBRUSH)0x0;
  local_98.lpszMenuName = (LPCWSTR)0x0;
  local_98.lpfnWndProc = (WNDPROC)&LAB_1400011c0;
  local_98.lpszClassName = L"LegitWindowClass";
  local_98.hInstance = param_1;
  RegisterClassW(&local_98);
  hWnd = CreateWindowExW(0,local_98.lpszClassName,L"",0,0,0,0,0,(HWND)0x0,(HMENU)0x0,param_1,
                         (LPVOID)0x0);
  PostMessageW(hWnd,0x474,0,0); // è‡ªè¨‚è¨Šæ¯ï¼ˆWM_USER + 0x74ï¼‰ï¼Œè§¸ç™¼ WndProc ä¸­å°æ‡‰ case 0x474 çš„é‚è¼¯
  iVar1 = GetMessageW(&local_48,(HWND)0x0,0,0);
  while (iVar1 != 0) {
    TranslateMessage(&local_48);
    DispatchMessageW(&local_48);
    iVar1 = GetMessageW(&local_48,(HWND)0x0,0,0);
  }
  FUN_140001ac0(local_18 ^ (ulonglong)auStackY_f8);
  return;
}
```
é€™å€‹å‡½å¼ä¸»è¦æ˜¯å»ºç«‹ä¸€å€‹éš±è—çš„è¦–çª—ï¼Œä¸¦ç«‹åˆ»è§¸ç™¼ä¸€å€‹è‡ªè¨‚çš„è¨Šæ¯ `0x474`ï¼Œæ¥è‘—é€²å…¥ Loop ç­‰å¾…ã€‚

æ‰€ä»¥å¯ä»¥åˆ¤æ–·ï¼Œè™•ç† flag çš„åœ°æ–¹å¾ˆå¯èƒ½åœ¨ `LAB_1400011c0` å‡½å¼ï¼ˆWndProcï¼‰ï¼Œ case 0x474 çš„ä½ç½®ï¼Œå¦‚ä¸‹ï¼š

```c
void UndefinedFunction_1400011c0(HWND param_1,undefined8 param_2,WPARAM param_3,LPARAM param_4)

{
  undefined4 uVar1;
  undefined4 uVar2;
  undefined4 uVar3;
  undefined8 uVar4;
  undefined8 *puVar5;
  code *pcVar6;
  errno_t eVar7;
  int iVar8;
  code *lpAddress;
  basic_ostream<> *this;
  longlong lVar9;
  undefined8 *puVar10;
  void *pvVar11;
  code *pcVar12;
  wchar_t *lpText;
  undefined1 auStackY_138 [32];
  FILE *pFStack_108;
  void *apvStack_100 [2];
  undefined8 uStack_f0;
  ulonglong uStack_e8;
  undefined8 uStack_e0;
  undefined8 uStack_d8;
  undefined8 uStack_d0;
  undefined8 uStack_c8;
  undefined8 uStack_c0;
  undefined4 uStack_b8;
  undefined1 uStack_b4;
  undefined8 uStack_a8;
  undefined8 uStack_a0;
  undefined8 uStack_98;
  undefined8 uStack_90;
  undefined8 uStack_88;
  undefined8 uStack_80;
  undefined8 uStack_78;
  undefined8 uStack_70;
  undefined8 uStack_68;
  undefined8 uStack_60;
  undefined8 uStack_58;
  undefined2 uStack_50;
  ulonglong uStack_48;
  
  uStack_48 = DAT_140005008 ^ (ulonglong)auStackY_138;
  uStack_f0 = 0;
  uStack_e8 = 0xf;
  apvStack_100[0] = (void *)0x0;
  FUN_1400016d0((longlong *)apvStack_100,param_2,0);
  uStack_e0 = 0;
  uStack_d8 = 0;
  uStack_d0 = 0;
  uStack_c8 = 0;
  uStack_c0 = 0;
  uStack_b8 = 0;
  uStack_b4 = 0;
  eVar7 = fopen_s(&pFStack_108,"flag.txt","r");
  if ((eVar7 == 0) && (pFStack_108 != (FILE *)0x0)) {
    fread(&uStack_e0,1,0x2c,pFStack_108);
    uStack_b4 = 0;
    fclose(pFStack_108);
    uStack_a8 = 0;
    uStack_a0 = 0;
    uStack_98 = 0;
    uStack_90 = 0;
    uStack_88 = 0;
    uStack_80 = 0;
    uStack_78 = 0;
    uStack_70 = 0;
    uStack_68 = 0;
    uStack_60 = 0;
    uStack_58 = 0;
    uStack_50 = 0;
    MultiByteToWideChar(0,0,(LPCSTR)&uStack_e0,-1,(LPWSTR)&uStack_a8,0x2d);
    lpAddress = (code *)VirtualAlloc((LPVOID)0x0,0x272,0x1000,0x40);
    if (lpAddress == (code *)0x0) {
      this = FUN_140001840((basic_ostream<> *)cerr_exref);
      std::basic_ostream<>::operator<<(this,FUN_140001a00);
    }
    else {
      lVar9 = 4;
      puVar5 = (undefined8 *)&DAT_140005040;
      pcVar6 = lpAddress;
      do {
        pcVar12 = pcVar6;
        puVar10 = puVar5;
        uVar4 = puVar10[1];
        *(undefined8 *)pcVar12 = *puVar10;
        *(undefined8 *)(pcVar12 + 8) = uVar4;
        uVar4 = puVar10[3];
        *(undefined8 *)(pcVar12 + 0x10) = puVar10[2];
        *(undefined8 *)(pcVar12 + 0x18) = uVar4;
        uVar4 = puVar10[5];
        *(undefined8 *)(pcVar12 + 0x20) = puVar10[4];
        *(undefined8 *)(pcVar12 + 0x28) = uVar4;
        uVar4 = puVar10[7];
        *(undefined8 *)(pcVar12 + 0x30) = puVar10[6];
        *(undefined8 *)(pcVar12 + 0x38) = uVar4;
        uVar4 = puVar10[9];
        *(undefined8 *)(pcVar12 + 0x40) = puVar10[8];
        *(undefined8 *)(pcVar12 + 0x48) = uVar4;
        uVar4 = puVar10[0xb];
        *(undefined8 *)(pcVar12 + 0x50) = puVar10[10];
        *(undefined8 *)(pcVar12 + 0x58) = uVar4;
        uVar4 = puVar10[0xd];
        *(undefined8 *)(pcVar12 + 0x60) = puVar10[0xc];
        *(undefined8 *)(pcVar12 + 0x68) = uVar4;
        uVar4 = puVar10[0xf];
        *(undefined8 *)(pcVar12 + 0x70) = puVar10[0xe];
        *(undefined8 *)(pcVar12 + 0x78) = uVar4;
        lVar9 = lVar9 + -1;
        puVar5 = puVar10 + 0x10;
        pcVar6 = pcVar12 + 0x80;
      } while (lVar9 != 0);
      uVar4 = puVar10[0x11];
      *(undefined8 *)(pcVar12 + 0x80) = puVar10[0x10];
      *(undefined8 *)(pcVar12 + 0x88) = uVar4;
      uVar4 = puVar10[0x13];
      *(undefined8 *)(pcVar12 + 0x90) = puVar10[0x12];
      *(undefined8 *)(pcVar12 + 0x98) = uVar4;
      uVar4 = puVar10[0x15];
      *(undefined8 *)(pcVar12 + 0xa0) = puVar10[0x14];
      *(undefined8 *)(pcVar12 + 0xa8) = uVar4;
      uVar4 = puVar10[0x17];
      *(undefined8 *)(pcVar12 + 0xb0) = puVar10[0x16];
      *(undefined8 *)(pcVar12 + 0xb8) = uVar4;
      uVar4 = puVar10[0x19];
      *(undefined8 *)(pcVar12 + 0xc0) = puVar10[0x18];
      *(undefined8 *)(pcVar12 + 200) = uVar4;
      uVar1 = *(undefined4 *)((longlong)puVar10 + 0xd4);
      uVar2 = *(undefined4 *)(puVar10 + 0x1b);
      uVar3 = *(undefined4 *)((longlong)puVar10 + 0xdc);
      *(undefined4 *)(pcVar12 + 0xd0) = *(undefined4 *)(puVar10 + 0x1a);
      *(undefined4 *)(pcVar12 + 0xd4) = uVar1;
      *(undefined4 *)(pcVar12 + 0xd8) = uVar2;
      *(undefined4 *)(pcVar12 + 0xdc) = uVar3;
      uVar1 = *(undefined4 *)((longlong)puVar10 + 0xe4);
      uVar2 = *(undefined4 *)(puVar10 + 0x1d);
      uVar3 = *(undefined4 *)((longlong)puVar10 + 0xec);
      *(undefined4 *)(pcVar12 + 0xe0) = *(undefined4 *)(puVar10 + 0x1c);
      *(undefined4 *)(pcVar12 + 0xe4) = uVar1;
      *(undefined4 *)(pcVar12 + 0xe8) = uVar2;
      *(undefined4 *)(pcVar12 + 0xec) = uVar3;
      *(undefined2 *)(pcVar12 + 0xf0) = *(undefined2 *)(puVar10 + 0x1e);
      if ((UINT)param_2 != 0x474) {
        VirtualFree(lpAddress,0,0x8000);
        DefWindowProcW(param_1,(UINT)param_2,param_3,param_4);
        if (0xf < uStack_e8) {
          pvVar11 = apvStack_100[0];
          if ((uStack_e8 + 1 < 0x1000) ||
             (pvVar11 = *(void **)((longlong)apvStack_100[0] + -8),
             (ulonglong)((longlong)apvStack_100[0] + (-8 - (longlong)pvVar11)) < 0x20)) {
            free(pvVar11);
            goto LAB_140001341;
          }
          goto LAB_14000151e;
        }
        goto LAB_140001341;
      }
      iVar8 = (*lpAddress)(&uStack_e0);
      lpText = L"OK right!!";
      if (iVar8 != 1) {
        lpText = L"Sorry......Keep it up";
      }
      MessageBoxW(param_1,lpText,L"<< MSG >>",0);
      VirtualFree(lpAddress,0,0x8000);
      PostQuitMessage(0);
    }
    if (uStack_e8 < 0x10) goto LAB_140001341;
    pvVar11 = apvStack_100[0];
    if (0xfff < uStack_e8 + 1) {
      pvVar11 = *(void **)((longlong)apvStack_100[0] + -8);
      lVar9 = (longlong)apvStack_100[0] - (longlong)pvVar11;
joined_r0x000140001518:
      if (0x1f < lVar9 - 8U) {
LAB_14000151e:
                    /* WARNING: Subroutine does not return */
        _invalid_parameter_noinfo_noreturn();
      }
    }
  }
  else {
    MessageBoxW((HWND)0x0,L"Can\'t find or open fileï¼",L"ERROR",0x10);
    PostQuitMessage(0);
    if (uStack_e8 < 0x10) goto LAB_140001341;
    pvVar11 = apvStack_100[0];
    if (0xfff < uStack_e8 + 1) {
      pvVar11 = *(void **)((longlong)apvStack_100[0] + -8);
      lVar9 = (longlong)apvStack_100[0] - (longlong)pvVar11;
      goto joined_r0x000140001518;
    }
  }
  free(pvVar11);
LAB_140001341:
  FUN_140001ac0(uStack_48 ^ (ulonglong)auStackY_138);
  return;
}
```

```c
MultiByteToWideChar(0, 0, (LPCSTR)&uStack_e0, -1, 
                    (LPWSTR)&uStack_a8, 0x2d); // 0x2d = 45 å€‹å¯¬å­—å…ƒçš„ç·©è¡å€ã€‚
```

åˆ°é€™é‚Šæˆ‘å€‘å·²ç¶“å¯ä»¥çœ‹å‡ºï¼Œé€™å€‹å‡½å¼æœƒå˜—è©¦æ‰“é–‹ `flag.txt` æª”æ¡ˆï¼Œä¸¦è®€å–å…§å®¹åˆ° `uStack_e0` é–‹å§‹çš„ç·©è¡å€ä¸­ã€‚
æ¥è‘—å°‡è®€å–åˆ°çš„ flag å°‡è®€å–çš„ ASCII flag è½‰ç‚º UTF-16ï¼Œä¸¦å­˜æ”¾åˆ° `uStack_a8` é–‹å§‹çš„ç·©è¡å€ä¸­ã€‚  

æ¥è‘—  

```c
lpAddress = VirtualAlloc(NULL, 0x272, 0x1000, 0x40);
//                              ^^^^  ^^^^^   ^^^^
//                              626B  MEM_    PAGE_EXECUTE_READWRITE
//                                    COMMIT
```

- é…ç½® 626 bytes çš„ å¯è®€å¯«åŸ·è¡Œ è¨˜æ†¶é«”
- `0x40` = `PAGE_EXECUTE_READWRITE`: å…è¨±åŸ·è¡Œ shellcode

```c
lVar9 = 4;
puVar5 = &DAT_140005040;  // <- åµŒå…¥çš„åŠ å¯† shellcode
pcVar6 = lpAddress;
do {
  // æ¯æ¬¡è¤‡è£½ 128 bytes (0x80)
  memcpy_unrolled(pcVar6, puVar5, 0x80);
  lVar9--;
  puVar5 += 0x10;
  pcVar6 += 0x80;
} while (lVar9 != 0);
// å†è¤‡è£½å‰©é¤˜çš„ 114 bytes (626 - 512)
```

- `DAT_140005040`: å­˜æ”¾åŠ å¯†/æ··æ·†çš„æ©Ÿå™¨ç¢¼ï¼ˆç¸½è¨ˆ 626 bytesï¼‰
- æ‰‹å‹•å±•é–‹çš„ memcpyï¼ˆç·¨è­¯å™¨æœ€ä½³åŒ–ï¼‰

```c
if ((UINT)param_2 != 0x474) {  // éè§¸ç™¼è¨Šæ¯ -> æ¸…ç†
  VirtualFree(lpAddress, 0, 0x8000);
  DefWindowProcW(...);
  return;
}

// åŸ·è¡Œ shellcode
iVar8 = (*lpAddress)(&uStack_e0);  // <- å‘¼å«å‹•æ…‹ç”Ÿæˆçš„å‡½æ•¸
                                    //   å‚³å…¥ flag å­—ä¸²

if (iVar8 == 1) {
  MessageBoxW(param_1, L"OK right!!", L"<< MSG >>", 0);
} else {
  MessageBoxW(param_1, L"Sorry......Keep it up", L"<< MSG >>", 0);
}
```

- `lpAddress(&uStack_e0)`: å°‡ flag å‚³çµ¦å‹•æ…‹ç”Ÿæˆçš„é©—è­‰å‡½æ•¸
- return  1 â†’ æ­£ç¢ºï¼Œ0 â†’ éŒ¯èª¤

#### Shellcode åˆ†æ

ç¾åœ¨æˆ‘å€‘çŸ¥é“é©—è­‰ flag çš„é‚è¼¯åœ¨ shellcode ä¸­ï¼Œå› æ­¤æˆ‘å€‘ç”¨ Ghidra å°‡ä½å€ `140005040` åˆ° `1400052B1` 
(0x140005040 + 0x271 = 0x1400052B1) é¸èµ·ä¾†å¼·åˆ¶åçµ„è­¯æˆ Codeï¼Œå¯ä»¥ç²å¾—ä¸‹é¢çµæœï¼š


```c
undefined8 UndefinedFunction_140005132(undefined8 param_1,int *param_2)
{
  longlong unaff_RBP;

  *param_2 = *param_2 + 1;
  while (*(int *)(unaff_RBP + -0xb8) < 0x2b) {
    *(undefined1 *)(unaff_RBP + -0xa0 + (longlong)*(int *)(unaff_RBP + -0xb8)) =
         *(undefined1 *)
          (*(longlong *)(unaff_RBP + -200) + (longlong)*(int *)(unaff_RBP + -0xb8) + 1);
    *(undefined1 *)(unaff_RBP + -0xa0 + (longlong)(*(int *)(unaff_RBP + -0xb8) + 1)) =
         *(undefined1 *)(*(longlong *)(unaff_RBP + -200) + (longlong)*(int *)(unaff_RBP + -0xb8));
    *(int *)(unaff_RBP + -0xb8) = *(int *)(unaff_RBP + -0xb8) + 2;
  }
  *(undefined4 *)(unaff_RBP + -0xb4) = 0;
  while (*(int *)(unaff_RBP + -0xb4) < 0x2c) {
    *(undefined4 *)(unaff_RBP + -0xbc) = 0;
    *(undefined4 *)(unaff_RBP + -0xb0) = 0;
    while (*(int *)(unaff_RBP + -0xb0) < 4) {
      *(uint *)(unaff_RBP + -0xbc) =
           (uint)*(byte *)(unaff_RBP + -0xa0 +
                          (longlong)(*(int *)(unaff_RBP + -0xb0) + *(int *)(unaff_RBP + -0xb4))) |
           *(int *)(unaff_RBP + -0xbc) << 8;
      *(int *)(unaff_RBP + -0xb0) = *(int *)(unaff_RBP + -0xb0) + 1;
    }
    *(uint *)(unaff_RBP + -0xa4) = (*(int *)(unaff_RBP + -0xbc) * 2 ^ 0x94e590U) + 0x14;
    *(undefined4 *)(unaff_RBP + -0xac) = 3;
    while (-1 < *(int *)(unaff_RBP + -0xac)) {
      *(char *)(unaff_RBP + -0x70 +
               (longlong)(*(int *)(unaff_RBP + -0xb4) + (3 - *(int *)(unaff_RBP + -0xac)))) =
           (char)(*(uint *)(unaff_RBP + -0xa4) >> ((byte)(*(int *)(unaff_RBP + -0xac) << 3) & 0x1f))
      ;
      *(int *)(unaff_RBP + -0xac) = *(int *)(unaff_RBP + -0xac) + -1;
    }
    *(int *)(unaff_RBP + -0xb4) = *(int *)(unaff_RBP + -0xb4) + 4;
  }
  *(undefined8 *)(unaff_RBP + -0x40) = 0x6e6732f63277168a;
  *(undefined8 *)(unaff_RBP + -0x38) = 0x426306dc420bfef2;
  *(undefined8 *)(unaff_RBP + -0x30) = 0x5a5bfcc65c8956d8;
  *(undefined8 *)(unaff_RBP + -0x28) = 0x62397cd2602358ea;
  *(undefined8 *)(unaff_RBP + -0x20) = 0x42230cd8142f2ae6;
  *(undefined4 *)(unaff_RBP + -0x18) = 0x6e1ff4c8;
  *(undefined1 *)(unaff_RBP + -0x14) = 0;
  *(undefined4 *)(unaff_RBP + -0xa8) = 0;
  while( true ) {
    if (0x2b < *(int *)(unaff_RBP + -0xa8)) {
      return 1;
    }
    if (*(char *)(unaff_RBP + -0x70 + (longlong)*(int *)(unaff_RBP + -0xa8)) !=
        *(char *)(unaff_RBP + -0x40 + (longlong)*(int *)(unaff_RBP + -0xa8))) break;
    *(int *)(unaff_RBP + -0xa8) = *(int *)(unaff_RBP + -0xa8) + 1;
  }
  return 0;
}
```

é€™å°±æ˜¯å®Œæ•´çš„é©—è­‰é‚è¼¯ï¼Œå°‡é€™æ®µåçµ„è­¯å¾Œçš„çµæœä¸Ÿçµ¦ LLM é€²è¡Œåˆ†æï¼Œå¯ä»¥å¾—åˆ°ä»¥ä¸‹çš„ Python é€†æ¨ç¨‹å¼ï¼š

```python
#!/usr/bin/env python3

# å®Œæ•´æœŸæœ›å€¼
expected_bytes_new = bytes(
    [
        0x8A,
        0x16,
        0x77,
        0x32,
        0xF6,
        0x32,
        0x67,
        0x6E,
        0xF2,
        0xFE,
        0x0B,
        0x42,
        0xDC,
        0x06,
        0x63,
        0x42,
        0xD8,
        0x56,
        0x89,
        0x5C,
        0xC6,
        0xFC,
        0x5B,
        0x5A,
        0xEA,
        0x58,
        0x23,
        0x60,
        0xD2,
        0x7C,
        0x39,
        0x62,
        0xE6,
        0x2A,
        0x2F,
        0x14,
        0xD8,
        0x0C,
        0x23,
        0x42,
        0xC8,
        0xF4,
        0x1F,
        0x6E,
    ]
)


def decode_new():

    # æ­¥é©Ÿ 2 é€†é‹ç®—
    after_step2 = bytearray(len(expected_bytes_new))

    for i in range(0, len(expected_bytes_new), 4):
        temp_encoded = int.from_bytes(expected_bytes_new[i : i + 4], "big")

        temp = (temp_encoded - 0x14) & 0xFFFFFFFF
        temp_xor = temp ^ 0x94E590

        if temp_xor & 1:
            print(f"âš ï¸  ä½ç½® {i}: ç„¡æ³•é™¤ä»¥ 2")

        value = temp_xor >> 1

        for j in range(3, -1, -1):
            if i + (3 - j) < len(after_step2):
                after_step2[i + (3 - j)] = (value >> (j * 8)) & 0xFF

    # æ­¥é©Ÿ 1 é€†é‹ç®—ï¼ˆäº¤æ›ï¼‰
    flag = bytearray(len(after_step2))
    for i in range(0, len(after_step2) - 1, 2):
        flag[i] = after_step2[i + 1]
        flag[i + 1] = after_step2[i]

    if len(after_step2) % 2 == 1:
        flag[-1] = after_step2[-1]

    return bytes(flag)


# è§£å¯†
new_flag = decode_new()

print(f"Hex: {new_flag.hex()}")

try:
    decoded = new_flag.decode("ascii")
    print(f"âœ… ASCII: {decoded}")

    if all(32 <= b <= 126 for b in new_flag):
        print("âœ… å…¨éƒ¨å¯åˆ—å°ï¼")
        print(f"\nğŸ¯ çœŸæ­£çš„ Flag: {decoded}")
    else:
        print("âš ï¸  å•é¡Œå€åŸŸ:")
        for i in range(24, 32):
            if new_flag[i] < 32 or new_flag[i] > 126:
                print(f"   ä½ç½® {i}: 0x{new_flag[i]:02X}")

except UnicodeDecodeError:
    print("âŒ ç„¡æ³•è§£ç¢¼")

print("=" * 70)
```

å®Œæ•´çš„ flag å¦‚ä¸‹ï¼š

```txt
AEGIS{eA5y_wIn_Call64ck_function_sHeLl_c0de}
```

## çµæœè¨˜éŒ„

### å°çµ„æˆç¸¾

<Image src={score1} alt="å°çµ„æˆç¸¾" />

### åæ¬¡ç¸½è¡¨

<Image src={score2} alt="åæ¬¡ç¸½è¡¨" />

